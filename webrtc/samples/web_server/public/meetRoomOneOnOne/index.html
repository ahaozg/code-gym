<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>meeting room one on one</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      .header {
        display: flex;
        justify-content: space-around;
        align-items: center;
        height: 100px;
      }
      table {
        width: 100%;
        height: 300px;
      }
      td {
        width: 50%;
        border: 1px solid #333;
      }

      video {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <button id="jsConnectServer">connect server</button>
      <button id="jsLeave" disabled>leave</button>
    </div>
    <table>
      <tr>
        <td><video id="jsLocalVideo" autoplay playsinline></video></td>
        <td><video id="jsRemoteVideo" autoplay playsinline></video></td>
      </tr>
    </table>
    <script src="https://cdn.socket.io/4.4.0/socket.io.min.js"></script>
    <script src="http://webrtc.github.io/adapter/adapter-latest.js"></script>
    <script>
      window.onload = function () {
        const jsConnectServer = document.querySelector("#jsConnectServer");
        const jsLeave = document.querySelector("#jsLeave");

        const jsLocalVideo = document.querySelector("#jsLocalVideo");
        const jsRemoteVideo = document.querySelector("#jsRemoteVideo");

        let localStream, socket, pc;

        const roomId = "123456";

        let state = "init";

        function handleStart() {
          // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象
          if (navigator.mediaDevices === undefined) {
            navigator.mediaDevices = {};
          }

          // 一些浏览器部分支持mediaDevices。我们不能直接给对象设置 getUserMedia
          // 因为这样可能会覆盖已有的属性。这里我们只会在没有 getUserMedia 属性的时候添加它。
          if (navigator.mediaDevices.getUserMedia === undefined) {
            navigator.mediaDevices.getUserMedia = function (constraints) {
              // 首先，如果有 getUserMedia 的话，就获得它
              var getUserMedia =
                navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

              // 一些浏览器根本没实现它 - 那么就返回一个 error 到 promise 的 reject 来保持一个统一的接口
              if (!getUserMedia) {
                return Promise.reject(
                  new Error("getUserMedia is not implemented in this browser")
                );
              }

              // 否则，为老的 navigator.getUserMedia 方法包裹一个 Promise
              return new Promise(function (resolve, reject) {
                getUserMedia.call(navigator, constraints, resolve, reject);
              });
            };
          }

          navigator.mediaDevices
            .getUserMedia({
              audio: false,
              video: {
                width: 480,
                height: 320,
                frameRate: 15,
              },
            })
            .then(handleUserMedia)
            .catch((err) => {
              console.error("fail getUserMedia", err);
            });
        }

        function handleUserMedia(stream) {
          jsLocalVideo.srcObject = stream;
          localStream = stream;

          handleConnectSignalServer();
        }

        function handleConnectSignalServer() {
          socket = io.connect();

          socket.on("joined", (roomID, userID) => {
            console.log("receive joined message:", roomID, userID);
            state = 'joined';
            createPeerConnection();
            jsConnectServer.disabled = true;
            jsLeave.disabled = false;
            console.log("receive joined message:state=", state);
          });

          socket.on("otherJoin", (roomID, userID) => {
            console.log("receive otherJoin message:", roomID, userID);
            if (state === 'joined_unbind') {
              createPeerConnection();
            }
            state = 'joined_conn';
            console.log("receive otherJoin message:state=", state);
          });

          socket.on("full", (roomID, userID) => {
            console.log("receive full message:", roomID, userID);
            state = 'leaved';
            jsConnectServer.disabled = false;
            jsLeave.disabled = true;
            socket.disconnect();
            console.log("receive full message:state=", state);
          });

          socket.on("leaved", (roomID, userID) => {
            console.log("receive leaved message:", roomID, userID);
            state = 'leaved';
            jsConnectServer.disabled = false;
            jsLeave.disabled = true;
            socket.disconnect();
            console.log("receive leaved message:state", state);
          });

          socket.on("bye", (roomID, userID) => {
            console.log("receive bye message:", roomID, userID);
            state = 'join_unbind';
            closePeerConnection();
            closeLocalStream();
            console.log("receive bye message:state", state);
          });

          socket.on("message", (roomID, userID) => {
            console.log("receive client  message:", roomID, userID);
          });

          socket.emit("join", roomId);
        }

        function createPeerConnection() {
          console.log('create peerConnection!');
          if (!pc) {
            const options = {
              iceServers: []
            };
            pc = new RTCPeerConnection(options);
            
            pc.onicecandidate = e => {
              if (e.candidate) {
                console.log('find a new candidate', e.candidate);
              }
            }

            pc.ontrack = e => {
              jsRemoteVideo.srcObject = e.streams[0];
            }
          }
          
          if (localStream) {
            localStream.getTracks().forEach(track => {
              pc.addTrack(track);
            })
          }

        }

        function closePeerConnection() {
          console.log('close peerConnection!');
          if (pc) {
            pc.close();
            pc = null;
          }
        }

        function closeLocalStream() {
          if (localStream) {
            localStream.getTracks().forEach(track => {
              track.stop();
            })
            localStream = null;
          }
        }

        function handleCall() {
          pc1 = new RTCPeerConnection();
          pc2 = new RTCPeerConnection();

          pc1.onicecandidate = (e) => {
            pc2.addIceCandidate(e.candidate);
          };

          pc2.ontrack = (e) => {
            jsRemoteVideo.srcObject = e.streams[0];
          };

          localStream.getTracks().forEach((track) => {
            pc1.addTrack(track, localStream);
          });

          const offerOptions = {
            offerToReceiveAudio: 0,
            offerToReceiveVideo: 1,
          };

          pc1
            .createOffer(offerOptions)
            .then(getOffer)
            .catch((err) => {
              console.error("fail to create offer", err);
            });
        }

        function getOffer(desc) {
          pc1.setLocalDescription(desc);

          // send desc to signals
          // receive desc from signal

          pc2.setRemoteDescription(desc);
          pc2
            .createAnswer()
            .then(getAnswer)
            .catch((err) => {
              console.error("fail to create answer", err);
            });
        }

        function getAnswer(desc) {
          pc2.setLocalDescription(desc);

          // send desc to signals
          // receive desc from signal

          pc1.setRemoteDescription(desc);
        }

        function handleHangup() {
          pc1.close();
          pc2.close();
          pc1 = null;
          pc2 = null;
        }

        function handleLeave() {
          if (socket) {
            socket.emit("leave", roomId);
          }
          closePeerConnection();
          closeLocalStream();
          jsConnectServer.disabled = false;
          jsLeave.disabled = true;
        }

        jsConnectServer.onclick = handleStart;
        jsLeave.onclick = handleLeave;
      };
    </script>
  </body>
</html>
